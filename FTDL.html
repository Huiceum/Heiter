<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>家系圖描述語言 (FTDL) 渲染器 beta版本</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 95%;
            max-width: 1400px; 
            margin: 0 auto;
            background-color: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        
        h1, h2 {
            color: #1a237e;
            border-bottom: 2px solid #7986cb;
            padding-bottom: 10px;
            margin-top: 0;
        }
         h2.usage-title { margin-top: 30px; }

        /* New Dialogue Field Styles */
        #dialogue-container {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e8eaf6;
            border-radius: 8px;
        }
        #user-text-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #7986cb;
            border-radius: 6px;
            font-size: 1em;
        }
        #run-dialogue-btn {
            padding: 10px 20px;
            background-color: #303f9f; /* Slightly darker than other buttons */
        }
        #run-dialogue-btn:hover {
            background-color: #1a237e;
        }

        /* Loading Overlay Styles */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 10000; /* Ensure it's on top of everything */
            display: none; /* Initially hidden */
        }
        
        .editor-container {
            display: flex;
            flex-direction: column; 
            gap: 20px;
            margin-bottom: 25px;
            min-height: 500px; 
        }

        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row;
                height: 600px; 
            }
        }
        
        #ftdl-editor {
            flex: 1;
            padding: 15px;
            border: 1px solid #d1d9e6; 
            border-radius: 8px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            height: 300px;
            resize: vertical;
            background-color: #f8f9fa;
        }
         @media (min-width: 768px) { #ftdl-editor { height: 100%; } }
        
        #preview-wrapper {
            flex: 1.5; 
            border: 1px solid #d1d9e6;
            border-radius: 8px;
            padding: 0; 
            overflow: hidden;
            position: relative;
            background-color: #fff;
            height: 400px;
        }
        @media (min-width: 768px) { #preview-wrapper { height: 100%; } }

        #preview {
            width: 100%;
            height: 100%;
            overflow: auto; 
            cursor: grab; 
        }
        #preview:active { cursor: grabbing; }


        #family-tree-container {
            display: inline-block; 
            padding: 20px;
            transform-origin: top left; 
            transition: transform 0.2s ease-out;
            min-width: 100%; 
            text-align: center; 
        }
        
        .render-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }

        button {
            background-color: #3f51b5;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #303f9f;
        }
        button:disabled {
            background-color: #9fa8da;
            cursor: not-allowed;
        }

        .zoom-controls button {
            padding: 8px 12px;
            font-size: 14px;
            background-color: #5c6bc0;
        }
        .zoom-controls button:hover { background-color: #3f51b5; }
        
        /* --- Family Tree Elements --- */
        .family-tree-root {
            display: inline-flex; 
            flex-direction: column;
            align-items: center;
            gap: 40px;
            padding: 20px;
        }

        .family-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }

        .couple-row {
            display: flex;
            align-items: flex-start; 
            justify-content: center;
            position: relative;
        }

        .person {
            border: 2px solid #7986cb; 
            border-radius: 8px; 
            padding: 8px 12px;
            margin: 0 5px; 
            width: 100px; /* 例如 */
            height: 100px;  /* 例如，矩形可以長寬不同 */
            box-sizing: border-box; /* 確保 padding 和 border 不會增加總大小 */
            text-align: center;
            background-color: #e8eaf6; 
            position: relative; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 1; 
            
        }
        .person:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .person .age {
            position: absolute;
            top: -20px; 
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #555;
            background-color: rgba(255,255,255,0.8);
            padding: 1px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .person.female {
            width: 100px;  /* 例如 */
            height: 100px; /* 圓形長寬必須相等 */
            border-radius: 50%;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #fce4ec; 
            border-color: #f48fb1; 
        }
        .person.female .age { top: -22px; }


        .person .name { font-weight: bold; font-size: 1em; margin-bottom: 3px; }
        .person .dates { font-size: 0.75em; color: #444; margin: 3px 0; }
        .person .note-preview { 
            font-size: 0.7em; 
            font-style: italic; 
            color: #363636; 
            margin-top: 4px; 
            max-height: 2.4em; 
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .proband {
            border-width: 3px;
            border-style: double;
            border-color: #ff9800; /* 一個醒目的顏色，例如橙色 */
        }

        .tooltip {
            visibility: hidden; opacity: 0; position: absolute;
            background-color: #333; color: #fff; text-align: left;
            padding: 10px; border-radius: 6px; z-index: 1000;
            min-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: opacity 0.2s, visibility 0.2s; pointer-events: none;
            font-size: 0.9em; line-height: 1.4;
        }
        .tooltip p { margin: 5px 0; }
        .tooltip strong { color: #80cbc4; } 

        .person:hover .tooltip { visibility: visible; opacity: 1; }


        .marriage-connector {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 0px; 
            position: relative;
            align-self: center; 
            min-height: 50px; 
        }

        .marriage-line {
            width: 40px; 
            height: 2px;
            background-color: #333;
            position: relative;
        }
        .marriage-line.status-divorced::before,
        .marriage-line.status-divorced::after {
            content: ''; position: absolute; width: 2px; height: 15px; 
            background-color: #333; top: 50%; left: 50%;
        }
        .marriage-line.status-divorced::before { transform: translate(-2px, -50%) rotate(45deg); }
        .marriage-line.status-divorced::after  { transform: translate(2px, -50%) rotate(-45deg); }

        .marriage-line.status-separated::before {
            content: ''; position: absolute; width: 2px; height: 15px;
            background-color: #333; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
        }
        
        .marriage-info {
            font-size: 0.7em; color: #666; position: absolute;
            top: 5px; 
            left: 50%; transform: translateX(-50%);
            background-color: rgba(240,240,240,0.8); padding: 1px 3px;
            border-radius: 3px; white-space: nowrap;
        }


        .children-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 0px; 
            position: relative;
        }

        .parent-to-children-line {
            width: 2px;
            height: 20px; 
            background-color: #333;
        }

        .siblings-connector-line-container { 
            position: relative; 
            height: 2px; 
            width: 100%; 
        }
        .siblings-connector-line { 
            height: 2px;
            background-color: #333;
            position: absolute; 
            top: 0;
        }
        
        .siblings-row {
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            padding-top: 20px; 
            position: relative;
            gap: 10px; 
        }
        .person.descendant-link::before {
            content: '';
            position: absolute;
            bottom: 100%; 
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 20px; 
            background-color: #333;
            z-index: 0; 
        }


        .error-message {
            color: #c62828; padding: 12px; background-color: #ffcdd2; 
            border-radius: 6px; margin-top: 15px; border: 1px solid #c62828;
            display: none; white-space: pre-wrap; 
        }
        .ftdl-syntax-guide {
            background-color: #e8eaf6; padding: 20px; border-radius: 8px;
            margin-top: 30px; font-size: 0.9em; line-height: 1.6;
        }
        .ftdl-syntax-guide h3 {
            color: #1a237e; margin-top: 0; border-bottom: 1px solid #7986cb;
            padding-bottom: 5px;
        }
        .ftdl-syntax-guide code {
            background-color: #fff; padding: 2px 5px; border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', monospace;
        }
        .ftdl-syntax-guide pre {
            background-color: #fff; padding: 10px; border-radius: 4px;
            overflow-x: auto;
        }

    #family-tree-container.no-gender-colors .person.male,
    #family-tree-container.no-gender-colors .person.female,
    #family-tree-container.no-gender-colors .person { 
        background-color: #ffffff !important; 
        border-color: #1e1e1e !important;    
    }

    .person.male {
        background-color: #e8eaf6;
        border-color: #7986cb;
    }
    .person.female {
        background-color: #fce4ec;
        border-color: #f48fb1;
    }

   #ftdl-editor {
        flex: 1;
        padding: 15px;
        border: 1px solid #d1d9e6; 
        border-radius: 8px;
        font-family: 'Fira Code', 'Consolas', monospace;
        font-size: 14px;
        line-height: 1.6;
        resize: vertical;
        background-color: #f8f9fa;
        transition: opacity 0.5s ease, transform 0.5s ease, max-width 0.5s ease, padding 0.5s ease, margin 0.5s ease, flex-basis 0.5s ease;
        max-width: 1000px; 
        min-width: 300px; 
        flex-basis: 40%; 
    }
    @media (min-width: 768px) { 
        #ftdl-editor { 
            height: 100%; 
        } 
    }

    #ftdl-editor.hidden {
        opacity: 0;
        transform: translateX(-100%); 
        max-width: 0;
        min-width: 0; 
        padding: 0;
        margin: 0;
        border-width: 0;
        flex-basis: 0 !important; 
    }

    #preview-wrapper {
        flex: 1.5; 
        border: 1px solid #d1d9e6;
        border-radius: 8px;
        padding: 0; 
        overflow: hidden;
        position: relative;
        background-color: #fff;
        transition: flex-grow 0.5s ease; 
    }
    @media (min-width: 768px) { 
        #preview-wrapper { 
            height: 100%; 
        } 
    }

    .editor-container.editor-hidden #preview-wrapper {
        flex-grow: 2.5; 
    }
    h3 {
        color: #c62828;
    }
    </style>
</head>
<body>
    <div id="loading-overlay">讀取中...</div>

    <div class="container">
        <h1>家系圖描述語言 (FTDL) 渲染器 beta版本</h1>
        
        <!-- New Dialogue Field -->
        <div id="dialogue-container">
            <input type="text" id="user-text-input" placeholder="請在此處輸入您的文本...">
            <button id="run-dialogue-btn">執行</button>
        </div>
        <h3>目前正在測試中，請注意不要將私人訊息及資料投入其中，可能導致個人或個案資料外洩！</h3>


        <button id="toggle-editor-btn" style="margin-left: 0; margin-bottom:10px;">隱藏編輯器</button> <!-- Adjusted margin -->
        
        <div class="editor-container">
            <textarea id="ftdl-editor" placeholder="在此輸入FTDL代碼...">
</textarea>
            <div id="preview-wrapper">
                <div id="preview">
                    <div id="family-tree-container"></div>
                </div>
            </div>
        </div>
        
        <div class="render-controls">
            <button id="render-btn">渲染家系圖</button>
            <div class="zoom-controls">
                <button id="zoom-in-btn">+</button>
                <button id="zoom-out-btn">-</button>
                <button id="zoom-reset-btn">100%</button>
            </div>
            <label style="margin-left: 20px;">
                <input type="checkbox" id="toggle-gender-color-btn" checked> 顯示性別顏色
                
            </label>
        </div>
        <div id="error-message" class="error-message"></div>

        <div class="ftdl-syntax-guide">
            <h2 class="usage-title">FTDL 使用說明</h2>
            <h3>基本結構</h3>
            <p>FTDL (Family Tree Description Language) 使用文字區塊來定義家系圖的各個元素。</p>
            
            <h3><code>person</code> - 定義個人</h3>
            <pre><code>person { 
    id: "unique_id";       // (必填) 唯一標識符
    name?: "顯示名稱";      // (可選)
    gender: "male"|"female"|"other"; // (必填) 性別，影響圖形 (男=方, 女=圓)
    birth?: "YYYY-MM-DD";   // (可選) 生日
    death?: "YYYY-MM-DD";   // (可選) 忌日
    proband?: true;         // (可選) 是否為案主 (會特別標註)
}</code></pre>

            <h3><code>relationship</code> - 定義關係</h3>
            <pre><code>relationship {
    partners: ["id1", "id2"]; // (必填) 伴侶雙方的id
    type?: "marriage"|"partnership"; // (可選, 默認 marriage)
    status?: "married"|"divorced"|"separated"|"widowed"|"annulled"; // (可選) 婚姻狀態
    start_date?: "YYYY-MM-DD";  // (可選) 關係開始日期
    end_date?: "YYYY-MM-DD";    // (可選) 關係結束日期 
    children?: ["child_id1", ...]; // (可選) 此關係的子女
}</code></pre>

            <h3><code>note for "person_id"</code> - 為個人添加備註</h3>
            <pre><code>note for "some_person_id" {
    text: "這裡填寫備註內容...";
}</code></pre>

            <h3><code>style for "selector"</code> - 自定義樣式</h3>
            <pre><code>style for "#gender=female" { fill_color: "#FFC0CB"; shape: "circle"; }
style for "person_id_to_highlight" { border_width: "3px"; border_color: "red"; }</code></pre>
            <p>選擇器 (selector) 可以是：個人ID (<code>"grandfather"</code>), 屬性 (<code>"#gender=male"</code>, <code>"#proband=true"</code>)。</p>
        </div>
    </div>

    <script>
 // FTDLParser Class (保持不變)
class FTDLParser {
    constructor() { this.reset(); }
    reset() {
        this.persons = {}; this.relationships = []; this.notes = [];
        this.styles = []; this.layout = {}; this.metadata = {};
    }
    parse(ftdlText) {
        this.reset();
        const cleanText = ftdlText.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
        const blockRegex = /(person|relationship|note for "([^"]+)"|style for "([^"]+)"|layout|metadata)\s*{([^}]*)}/g;
        let match;
        while ((match = blockRegex.exec(cleanText)) !== null) {
            const blockType = match[1].trim();
            const blockContent = match[4];
            const properties = this.parseProperties(blockContent);
            try {
                if (blockType === 'person') this.parsePerson(properties);
                else if (blockType === 'relationship') this.parseRelationship(properties);
                else if (blockType.startsWith('note for')) this.parseNote(match[2], properties);
                else if (blockType.startsWith('style for')) this.parseStyle(match[3], properties);
                else if (blockType === 'layout') this.parseLayout(properties);
                else if (blockType === 'metadata') this.parseMetadata(properties);
            } catch (e) {
                console.error(`Error parsing block: ${match[0]}\n`, e);
                throw new Error(`Error in ${blockType} block (content: ${blockContent.substring(0,30)}...): ${e.message}`);
            }
        }
        return { persons: this.persons, relationships: this.relationships, notes: this.notes, styles: this.styles, layout: this.layout, metadata: this.metadata };
    }
    parseProperties(propertiesStr) {
        const properties = {};
        const propRegex = /\s*([\w-]+)\s*:\s*(?:"([^"]*)"|\[((?:"[^"]*",?\s*)*[^\]]*)\]|([^,}]+))/g;
        let propMatch;
        while ((propMatch = propRegex.exec(propertiesStr)) !== null) {
            const key = propMatch[1];
            if (propMatch[2] !== undefined) properties[key] = propMatch[2]; 
            else if (propMatch[3] !== undefined) { 
                properties[key] = propMatch[3].split(',')
                    .map(item => item.trim().replace(/^"|"$/g, ''))
                    .filter(item => item.length > 0);
            } else if (propMatch[4] !== undefined) { 
                const value = propMatch[4].trim();
                if (value === 'true') properties[key] = true;
                else if (value === 'false') properties[key] = false;
                else if (!isNaN(Number(value))) properties[key] = Number(value);
                else properties[key] = value;
            }
        }
        return properties;
    }
    parsePerson(p) { if (!p.id) throw new Error('Person missing ID'); if(!p.gender) throw new Error(`Person ${p.id} missing gender`); this.persons[p.id] = p; }
    parseRelationship(p) { if (!p.partners || p.partners.length === 0) throw new Error('Relationship missing partners or partners array is empty'); if(!Array.isArray(p.partners)) p.partners = [p.partners]; if(p.children && !Array.isArray(p.children)) p.children = [p.children]; this.relationships.push(p); }
    parseNote(targetId, p) { this.notes.push({ target: targetId, ...p }); }
    parseStyle(selector, p) { this.styles.push({ selector: selector, ...p }); }
    parseLayout(p) { this.layout = p; }
    parseMetadata(p) { this.metadata = p; }
}
// FamilyTreeRenderer Class (保持不變)
class FamilyTreeRenderer {
    constructor(parsedData, previewElement, treeContainerElement) { // Added treeContainerElement
        this.data = parsedData;
        this.previewElement = previewElement;
        this.treeContainerElement = treeContainerElement; // Store reference to tree container
        this.renderedCouples = new Set(); 
        this.processedPersonsAsDescendants = new Set(); 
        this.injectDefaultStyles();
        this.tooltipElement = null;
        this.createSharedTooltip();

    }

    injectDefaultStyles() {
        if (!this.data.styles) {
            this.data.styles = [];
        }        // 檢查是否已存在針對 proband 的樣式，避免重複添加（可選，但更好）
        const probandStyleExists = this.data.styles.some(style => style.selector === "#proband=true");

        if (!probandStyleExists) {
            this.data.styles.push({
                selector: "#proband=true",
                border_width: "3px", 
                border_style: "double",
                border_color: "#ff9800"
            });
        }
    }

    createSharedTooltip() {
        this.tooltipElement = document.createElement('div');
        this.tooltipElement.className = 'tooltip';
        if (this.previewElement && this.previewElement.appendChild) { 
            this.previewElement.appendChild(this.tooltipElement);
        }
    }
    calculateAge(birthDateStr, deathDateStr) {
        if (!birthDateStr) return null;
        const birthYear = parseInt(birthDateStr.substring(0, 4));
        if (isNaN(birthYear)) return null;
        let endYear;
        if (deathDateStr) {
            endYear = parseInt(deathDateStr.substring(0, 4));
        } else {
            endYear = new Date().getFullYear();
        }
        if (isNaN(endYear)) return null; 
        return Math.max(0, endYear - birthYear);
    }
    
    render() {
        this.renderedCouples.clear();
        this.processedPersonsAsDescendants.clear();
        const treeRoot = document.createElement('div');
        treeRoot.className = 'family-tree-root';
        
        if (this.data && this.data.metadata && this.data.metadata.title) {
            const titleEl = document.createElement('h2');
            titleEl.textContent = this.data.metadata.title;
            titleEl.style.textAlign = 'center';
            titleEl.style.width = '100%';
            titleEl.style.marginBottom = '30px';
            treeRoot.appendChild(titleEl);
        }
        
        const rootPersons = this.findRootNodes(); 
        
        if (Array.isArray(rootPersons)) { 
            rootPersons.forEach(rootPersonId => {
                if (rootPersonId && !this.processedPersonsAsDescendants.has(rootPersonId)) { 
                    const familyNode = this.renderFamilyNode(rootPersonId, false); 
                    if (familyNode) treeRoot.appendChild(familyNode);
                }
            });
        }
        return treeRoot;
    }

    findRootNodes() {
        if (!this.data || !this.data.persons || !this.data.relationships) {
            return []; 
        }
        const allPersonsIds = Object.keys(this.data.persons);
        const childrenIds = new Set();
        if (Array.isArray(this.data.relationships)) {
            this.data.relationships.forEach(rel => {
                if (rel && rel.children && Array.isArray(rel.children)) { 
                    rel.children.forEach(childId => {
                        if (childId) childrenIds.add(childId); 
                    });
                }
            });
        }
        return allPersonsIds.filter(id => this.data.persons[id] && !childrenIds.has(id));
    }

    renderFamilyNode(personId, isDescendantInSiblingsRow) {
        const personDataOriginal = this.data.persons[personId];
        if (!personDataOriginal) return null;
        
        const personData = {...personDataOriginal};

        if (!isDescendantInSiblingsRow && this.processedPersonsAsDescendants.has(personId)) {
            return null; 
        }
        this.processedPersonsAsDescendants.add(personId); 

        const familyNodeDiv = document.createElement('div');
        familyNodeDiv.className = 'family-node';
        
        const coupleRowDiv = document.createElement('div');
        coupleRowDiv.className = 'couple-row';
        
        const personElement = this.renderPerson(personData, isDescendantInSiblingsRow);
         if (!personElement) return null; 
        coupleRowDiv.appendChild(personElement);

        let childrenToRender = null;
        let relationshipForChildren = null;

        const personRelationships = this.data.relationships.filter(r => r.partners && r.partners.includes(personId));
        
        for (const rel of personRelationships) {
            if (!rel.partners) continue;
            const otherPartnerId = rel.partners.find(p => p !== personId);

            if (otherPartnerId && this.data.persons[otherPartnerId]) {
                const coupleKey = [personId, otherPartnerId].sort().join('-');
                if (!this.renderedCouples.has(coupleKey)) {
                    this.renderedCouples.add(coupleKey);
                            
                    const partnerData = {...this.data.persons[otherPartnerId]}; 
                    const partnerElement = this.renderPerson(partnerData, false); 
                    if (!partnerElement) continue; 

                    const marriageConnector = this.renderMarriage(personId, otherPartnerId, rel);

                    const personIndex = rel.partners.indexOf(personId);
                    const partnerIndex = rel.partners.indexOf(otherPartnerId);

                    if (personIndex !== -1 && partnerIndex !== -1 && personIndex < partnerIndex) {
                        coupleRowDiv.appendChild(marriageConnector);
                		coupleRowDiv.appendChild(partnerElement);
                    } else if (personIndex !== -1 && partnerIndex !== -1 && partnerIndex < personIndex) {
                        coupleRowDiv.insertBefore(partnerElement, personElement);
                        coupleRowDiv.insertBefore(marriageConnector, personElement);
                    } else { 
                        coupleRowDiv.appendChild(marriageConnector);
                		coupleRowDiv.appendChild(partnerElement);
                    }
                            
                    if (rel.children && rel.children.length > 0) {
                        childrenToRender = rel.children;
                        relationshipForChildren = rel;
                    }
                    this.processedPersonsAsDescendants.add(otherPartnerId); 
                    break; 
                }
            } else if (rel.partners.length === 1 && rel.partners[0] === personId && rel.children && rel.children.length > 0) {
                 if (!childrenToRender) { 
                    childrenToRender = rel.children;
                    relationshipForChildren = rel;
                }
            }
        }
        familyNodeDiv.appendChild(coupleRowDiv);

        if (childrenToRender) {
            this.renderChildren(familyNodeDiv, childrenToRender, relationshipForChildren);
        }
        return familyNodeDiv;
    }
            
    renderPerson(personData, isDescendantInSiblingsRow = false) {
         if (!personData || !personData.id) {
            return null;
         }
        const personDiv = document.createElement('div');
        personDiv.className = 'person';
        personDiv.setAttribute('data-id', personData.id);

        if (personData.gender) personDiv.classList.add(personData.gender);
        if (personData.proband) personDiv.classList.add('proband');
        if (isDescendantInSiblingsRow) {
            personDiv.classList.add('descendant-link');
        }

        this.applyStyles(personDiv, personData); 

        if (personData.gender === 'female' && !personDiv.style.borderRadius && !personDiv.classList.contains('female') && !personDiv.style.borderTopLeftRadius ) {
            personDiv.classList.add('female');
        }


        const age = this.calculateAge(personData.birth, personData.death);
        if (age !== null && !(personData.proband)) { 
            let showAge = true;
            if (showAge) {
                const ageEl = document.createElement('span');
                ageEl.className = 'age';
                ageEl.textContent = personData.death ? `${age} (逝)` : age;
                personDiv.appendChild(ageEl);
            }
        }

        if (personData.name) {
            const nameEl = document.createElement('div');
            nameEl.className = 'name';
            nameEl.textContent = personData.name;
            personDiv.appendChild(nameEl);
        } else if (isDescendantInSiblingsRow || personData.gender === 'female') { 
             const nameEl = document.createElement('div');
             nameEl.className = 'name';
             nameEl.innerHTML = ' '; 
             personDiv.appendChild(nameEl);
        }
        
        if (personData.birth || personData.death) {
            const datesEl = document.createElement('div');
            datesEl.className = 'dates';
            let datesText = personData.birth ? personData.birth.substring(0,10) : '';
            if (personData.birth && personData.death) datesText += ' - ';
            else if (!personData.birth && personData.death) datesText += ' - '; 
            datesText += personData.death ? personData.death.substring(0,10) : '';
            
            datesEl.textContent = datesText.trim() === '-' ? '' : datesText;
            if (datesEl.textContent || (personData.birth && !personData.death)) { 
                personDiv.appendChild(datesEl);
            }
        }
        
        const personNotes = this.data.notes.filter(note => note.target === personData.id);
        if (personNotes.length > 0 && personNotes[0].text) {
            const notePreviewEl = document.createElement('div');
            notePreviewEl.className = 'note-preview';
            notePreviewEl.textContent = personNotes[0].text.split('\n')[0]; 
            personDiv.appendChild(notePreviewEl);
        }
        const tooltipContent = this.buildTooltipContent(personData, personNotes, age);
        personDiv.addEventListener('mousemove', (e) => {
            if (!this.tooltipElement) return;
            this.tooltipElement.innerHTML = tooltipContent;
            this.tooltipElement.style.visibility = 'visible';
            this.tooltipElement.style.opacity = '1';
            const previewRect = this.previewElement.getBoundingClientRect();
            let x = e.clientX - previewRect.left + this.previewElement.scrollLeft + 15;
            let y = e.clientY - previewRect.top + this.previewElement.scrollTop + 15;
            if (x + this.tooltipElement.offsetWidth > this.previewElement.scrollLeft + previewRect.width) {
                x = e.clientX - previewRect.left + this.previewElement.scrollLeft - this.tooltipElement.offsetWidth - 15;
            }
            if (y + this.tooltipElement.offsetHeight > this.previewElement.scrollTop + previewRect.height) {
                y = e.clientY - previewRect.top + this.previewElement.scrollTop - this.tooltipElement.offsetHeight - 15;
            }
            this.tooltipElement.style.left = `${x}px`; this.tooltipElement.style.top = `${y}px`;
        });
        personDiv.addEventListener('mouseleave', () => {
             if (!this.tooltipElement) return;
            this.tooltipElement.style.visibility = 'hidden'; this.tooltipElement.style.opacity = '0';
        });
        return personDiv;
    }

    buildTooltipContent(personData, notes, age) {
        if (!personData) return "";
        let html = `<p><strong>ID:</strong> ${personData.id || 'N/A'}</p>`;
        if (personData.name) html += `<p><strong>姓名:</strong> ${personData.name}</p>`;
        html += `<p><strong>性別:</strong> ${personData.gender || 'N/A'}</p>`;
        if (personData.birth) html += `<p><strong>生日:</strong> ${personData.birth}</p>`;
        if (personData.death) html += `<p><strong>忌日:</strong> ${personData.death}</p>`;
        if (age !== null) html += `<p><strong>年齡:</strong> ${age}${personData.death ? ' (逝世時)' : ''}</p>`;
        if (personData.proband) html += `<p style="color: lightgreen;"><strong>(案主)</strong></p>`;
        if (Array.isArray(notes)) {
            notes.forEach(note => {
                if (note && note.text) html += `<p><strong>備註:</strong> ${note.text.replace(/\n/g, '<br>')}</p>`;
            });
        }
        return html;
    }

    applyStyles(element, personData) {
        const genderColorToggle = document.getElementById('toggle-gender-color-btn');
        const showGenderColors = genderColorToggle ? genderColorToggle.checked : true;

        if (!this.data.styles || !Array.isArray(this.data.styles)) return;

        this.data.styles.forEach(style => {
            if (!style || !style.selector) return;
            let match = false;
            if (style.selector === personData.id) match = true;
            else if (style.selector === `#gender=${personData.gender}`) match = true;
            else if (style.selector === `#proband=true` && personData.proband) match = true;

            if (match) {
                if (style.fill_color && (showGenderColors || !style.selector.startsWith('#gender='))) {
                    element.style.backgroundColor = style.fill_color;
                }
                if (style.border_color && (showGenderColors || !style.selector.startsWith('#gender='))) {
                    element.style.borderColor = style.border_color;
                }

                if (style.border_width) element.style.borderWidth = style.border_width;
                if (style.border_style) element.style.borderStyle = style.border_style;
                
                if (style.shape === 'circle') {
                    element.classList.add('female'); 
                    element.style.borderRadius = '50%'; 
                } else if (style.shape === 'rectangle') {
                    element.classList.remove('female'); 
                    element.style.borderRadius = '8px'; 
                }
            }
        });
    }
    renderMarriage(person1Id, person2Id, relationship) {
        const marriageConnectorDiv = document.createElement('div');
        marriageConnectorDiv.className = 'marriage-connector';
        
        const lineDiv = document.createElement('div');
        lineDiv.className = 'marriage-line';
        if (relationship && relationship.status) {
            lineDiv.classList.add(`status-${relationship.status}`);
        }
        marriageConnectorDiv.appendChild(lineDiv);
        
        if (relationship && (relationship.start_date || relationship.status || relationship.end_date)) {
            const infoEl = document.createElement('div');
            infoEl.className = 'marriage-info';
            let text = '';
            if (relationship.start_date) text += `m. ${relationship.start_date.substring(0,4)}`;
            
            if (relationship.status && relationship.status !== "married" && relationship.status !== "widowed") {
                 text += (text ? ' ' : '') + `(${relationship.status.substring(0,3)}${relationship.end_date ? '. ' + relationship.end_date.substring(0,4) : ''})`;
            } else if (relationship.end_date && (relationship.status === "widowed" || (!relationship.status && this.data.persons[person1Id]?.death && this.data.persons[person2Id]?.death && (this.data.persons[person1Id].death === relationship.end_date || this.data.persons[person2Id].death === relationship.end_date) ))) {
                 text += (text ? ' ' : '') + `- ${relationship.end_date.substring(0,4)}`;
            } else if (relationship.end_date && !relationship.status) { 
                 const p1 = this.data.persons[person1Id];
                 const p2 = this.data.persons[person2Id];
                 if ((p1 && p1.death === relationship.end_date) || (p2 && p2.death === relationship.end_date)) {
                     text += (text ? ' ' : '') + `- ${relationship.end_date.substring(0,4)}`;
                 }
            }
            infoEl.textContent = text.trim();
            if (infoEl.textContent) lineDiv.appendChild(infoEl);
        }
        return marriageConnectorDiv;
    }

    renderChildren(parentNode, childrenIds, relationshipContext) {
        if (!childrenIds || childrenIds.length === 0) return;

        const childrenContainerDiv = document.createElement('div');
        childrenContainerDiv.className = 'children-container';

        const parentToChildrenLine = document.createElement('div');
        parentToChildrenLine.className = 'parent-to-children-line';
        childrenContainerDiv.appendChild(parentToChildrenLine);
        
        const siblingsConnectorLineContainer = document.createElement('div');
        siblingsConnectorLineContainer.className = 'siblings-connector-line-container';
        const siblingsConnectorLine = document.createElement('div'); 
        siblingsConnectorLine.className = 'siblings-connector-line';
        siblingsConnectorLineContainer.appendChild(siblingsConnectorLine);
        childrenContainerDiv.appendChild(siblingsConnectorLineContainer);


        const siblingsRowDiv = document.createElement('div');
        siblingsRowDiv.className = 'siblings-row';

        const childNodesRendered = [];
        childrenIds.forEach(childId => {
            const childPersonData = this.data.persons[childId];
            if (childPersonData) { 
                const childFamilyNode = this.renderFamilyNode(childId, true); 
                if (childFamilyNode) {
                   siblingsRowDiv.appendChild(childFamilyNode);
                   const descendantPersonElement = childFamilyNode.querySelector('.person.descendant-link');
                   if (descendantPersonElement) childNodesRendered.push(descendantPersonElement);
                }
            }
        });
        
        if (siblingsRowDiv.children.length > 0) {
            childrenContainerDiv.appendChild(siblingsRowDiv);
            parentNode.appendChild(childrenContainerDiv);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const editorTextarea = document.getElementById('ftdl-editor'); 
    const editorContainer = document.querySelector('.editor-container'); 
    const previewWrapper = document.getElementById('preview-wrapper'); 
    const renderBtn = document.getElementById('render-btn');
    const previewDiv = document.getElementById('preview'); 
    const treeContainer = document.getElementById('family-tree-container'); 
    const errorMessageDiv = document.getElementById('error-message');
    const toggleGenderColorBtn = document.getElementById('toggle-gender-color-btn');
    const toggleEditorBtn = document.getElementById('toggle-editor-btn'); 

    // New elements for dialogue
    const userTextInput = document.getElementById('user-text-input');
    const runDialogueBtn = document.getElementById('run-dialogue-btn');
    const loadingOverlay = document.getElementById('loading-overlay');

    // --- Helper Function to Manage Control States ---
    const allControls = [
        editorTextarea, renderBtn, toggleEditorBtn, toggleGenderColorBtn,
        userTextInput, runDialogueBtn,
        document.getElementById('zoom-in-btn'),
        document.getElementById('zoom-out-btn'),
        document.getElementById('zoom-reset-btn')
    ].filter(el => el); // Filter out nulls if any ID is mistyped

    function setControlsDisabled(isDisabled) {
        allControls.forEach(control => {
            if (control) control.disabled = isDisabled;
        });
        // Special handling for runDialogueBtn: it should always be re-enabled if not specifically processing its own task
        if (!isDisabled && runDialogueBtn && !loadingOverlay.style.display.includes('flex')) {
             runDialogueBtn.disabled = false;
        }
    }

    function showLoading(message = "讀取中...") {
        if (loadingOverlay) {
            loadingOverlay.textContent = message;
            loadingOverlay.style.display = 'flex';
        }
        setControlsDisabled(true);
    }

    function hideLoading() {
        if (loadingOverlay) {
            loadingOverlay.style.display = 'none';
        }
        setControlsDisabled(false);
    }
    
    // --- New Dialogue Functionality ---
    function generateRandomString(length) {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }

    async function submitToGoogleForm(userText, randomCode) {
        const formId = '1FAIpQLSedI18mqcM7RKrt9dyk-PPhkhhW5nS2GG9Lxbci0AfChNjidA';
        const formUrl = `https://docs.google.com/forms/d/e/${formId}/formResponse`;
        const formData = new FormData();
        formData.append('entry.1067260806', userText);
        formData.append('entry.1456608144', randomCode);

        try {
            const response = await fetch(formUrl, {
                method: 'POST',
                mode: 'no-cors', // Google Forms often require this for simple submissions
                body: formData
            });
            // With no-cors, we can't truly know if it succeeded, but we assume it did if no network error
            console.log('Form submission initiated for:', randomCode);
            return true;
        } catch (error) {
            console.error('Error submitting to Google Form:', error);
            alert('提交到Google表單時發生錯誤: ' + error.message);
            return false;
        }
    }
    
    function unescapeCsvValue(value) {
        if (typeof value !== 'string') return value;
        // Remove leading/trailing quotes if they exist (common in CSV)
        let unquoted = value.trim();
        if (unquoted.startsWith('"') && unquoted.endsWith('"')) {
            unquoted = unquoted.substring(1, unquoted.length - 1);
        }
        // Replace "" with " (doubled quotes are Excel's way of escaping quotes within a field)
        // Replace literal \n with actual newline characters
        return unquoted.replace(/""/g, '"').replace(/\\n/g, '\n');
    }


    async function pollForResult(randomCode) {
        const resultSheetId = '1W4YHC_nqWLzG4WC9rLr92TWpbMkOa3mVPkGPY8E5yVw';
        const resultUrlBase = `https://docs.google.com/spreadsheets/d/${resultSheetId}/gviz/tq?tqx=out:csv`;
        
        let attempts = 0;
        const maxAttempts = 60; // Poll for 5 minutes (60 attempts * 5 seconds)
        
        return new Promise((resolve, reject) => {
            const intervalId = setInterval(async () => {
                attempts++;
                if (attempts > maxAttempts) {
                    clearInterval(intervalId);
                    reject(new Error('輪詢超時：未能在指定時間內獲取結果。'));
                    return;
                }

                const resultUrl = `${resultUrlBase}&r=${Date.now()}`; // Cache-busting
                console.log(`Polling attempt ${attempts} for ${randomCode}...`);

                try {
                    const response = await fetch(resultUrl);
                    if (!response.ok) {
                        console.error('輪詢時網絡響應錯誤:', response.statusText, response.status);
                        if (response.status === 404 || response.status === 403) { // Non-recoverable errors
                             clearInterval(intervalId);
                             reject(new Error(`輪詢失敗：無法訪問試算表 (狀態 ${response.status})`));
                             return;
                        }
                        return; // For other network issues, continue polling
                    }
                    
                    const csvData = await response.text();
                    if (!csvData || csvData.trim() === "") {
                        console.log("輪詢：收到的CSV數據為空。");
                        return; // Empty response, continue polling
                    }

                    const parsedRows = parseComplexCsv(csvData);

                    // Start from index 1 of parsedRows to skip the header row, if present
                    // (gviz/tq?tqx=out:csv includes headers)
                    for (let rowIndex = 1; rowIndex < parsedRows.length; rowIndex++) {
                        const rowFields = parsedRows[rowIndex];

                        if (rowFields.length > 2) { // Ensure Column C (index 2) exists
                            const codeInSheet = rowFields[2]; // Value from Column C

                            if (codeInSheet === randomCode) {
                                if (rowFields.length > 3 && rowFields[3] !== undefined) { // Check Column D (index 3)
                                    const ftdlOutput = rowFields[3];
                                    // Check if column D is not effectively empty.
                                    // An empty cell in CSV might be represented as "" or just an empty string.
                                    // The parseComplexCsv should handle this, rowFields[3] will be the string.
                                    if (ftdlOutput.trim() !== '' || ftdlOutput === '') { // Allow actually empty string if that's the intended value
                                        clearInterval(intervalId);
                                        console.log('Result received from sheet for code ' + randomCode + ':', ftdlOutput);
                                        
                                        // The ```ftdl ... ``` wrapper:
                                        // If your Google Sheet cell literally contains these backticks and "ftdl",
                                        // and your FTDLParser class cannot handle them, you should strip them here.
                                        let finalFtdl = ftdlOutput;
                                        if (finalFtdl.startsWith("```ftdl\n")) {
                                           finalFtdl = finalFtdl.substring("```ftdl\n".length);
                                           if (finalFtdl.endsWith("\n```")) {
                                               finalFtdl = finalFtdl.substring(0, finalFtdl.length - "\n```".length);
                                           } else if (finalFtdl.endsWith("```")) { // In case no trailing newline before ```
                                               finalFtdl = finalFtdl.substring(0, finalFtdl.length - "```".length);
                                           }
                                        } else if (finalFtdl.startsWith("```") && finalFtdl.includes("\n")) {
                                            // Simpler check if just ``` at start and newline (e.g. ```\n...```)
                                            finalFtdl = finalFtdl.substring(finalFtdl.indexOf("\n") + 1);
                                             if (finalFtdl.endsWith("\n```")) {
                                               finalFtdl = finalFtdl.substring(0, finalFtdl.length - "\n```".length);
                                           } else if (finalFtdl.endsWith("```")) {
                                               finalFtdl = finalFtdl.substring(0, finalFtdl.length - "```".length);
                                           }
                                        }

                                        resolve(finalFtdl);
                                        return;
                                    }
                                }
                                // If code matched but Column D is effectively empty/not what we want, continue polling
                                console.log(`Random code ${randomCode} found, but FTDL column D is empty or undefined. Continuing poll.`);
                                break; // Exit this inner loop (parsedRows), setInterval will trigger next poll.
                            }
                        }
                    }
                    // If loop finishes, code not found in this fetch, continue polling.
                    if (loadingOverlay.style.display.includes('flex')) {
                        loadingOverlay.textContent = `檢查結果中 (${attempts}/${maxAttempts})...`;
                    }

                } catch (error) {
                    console.error('輪詢過程中發生錯誤:', error);
                    // Depending on the error, you might want to stop or continue.
                    // For now, it will continue polling unless maxAttempts is reached.
                }
            }, 5000); // Poll every 5 seconds
        });
    }

    if (runDialogueBtn && userTextInput && editorTextarea) {
        runDialogueBtn.addEventListener('click', async () => {
            const userText = userTextInput.value.trim();
            if (!userText) {
                alert('請輸入一些文本！');
                return;
            }

            showLoading("處理請求中...");
            
            const randomCode = generateRandomString(17);
            console.log('Generated Random Code:', randomCode);

            const submissionSuccess = await submitToGoogleForm(userText, randomCode);

            if (submissionSuccess) {
                try {
                    showLoading("正在從試算表獲取內容..."); // Update loading message
                    const resultText = await pollForResult(randomCode);
                    console.log('Result received from sheet:', resultText);
                    editorTextarea.value = resultText; // Directly use the unescaped result
                    alert('已成功獲取內容並填入編輯器！您可以點擊 "渲染家系圖" 來查看。');
                    userTextInput.value = ''; // Clear input after success
                } catch (error) {
                    console.error('輪詢或更新編輯器時出錯:', error);
                    alert('獲取結果時發生錯誤：' + error.message);
                }
            } else {
                // Error already alerted in submitToGoogleForm
            }
            hideLoading();
        });
    } else {
        console.warn("Dialogue related elements (user-text-input, run-dialogue-btn, ftdl-editor) not all found.");
    }


    // --- Existing FTDL App Functionality (Zoom, Pan, Render, Toggle, etc.) ---
    let currentScale = 1;
    let isPanning = false;
    let startX, startY, scrollLeftInit, scrollTopInit; 

    if (document.getElementById('zoom-in-btn') && treeContainer) {
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            currentScale = Math.min(3, currentScale + 0.1);
            treeContainer.style.transform = `scale(${currentScale})`;
        });
    }
    if (document.getElementById('zoom-out-btn') && treeContainer) {
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            currentScale = Math.max(0.2, currentScale - 0.1);
            treeContainer.style.transform = `scale(${currentScale})`;
        });
    }
    if (document.getElementById('zoom-reset-btn') && treeContainer) {
        document.getElementById('zoom-reset-btn').addEventListener('click', () => {
            currentScale = 1;
            treeContainer.style.transform = `scale(${currentScale})`;
        });
    }

    if (previewDiv) {
        previewDiv.addEventListener('mousedown', (e) => {
            if (e.target !== previewDiv && e.target !== treeContainer && !e.target.closest('.person')) return;
            isPanning = true;
            startX = e.pageX - previewDiv.offsetLeft;
            startY = e.pageY - previewDiv.offsetTop;
            scrollLeftInit = previewDiv.scrollLeft;
            scrollTopInit = previewDiv.scrollTop;
            previewDiv.style.cursor = 'grabbing';
        });
        previewDiv.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                previewDiv.style.cursor = 'grab';
            }
        });
        previewDiv.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                previewDiv.style.cursor = 'grab';
            }
        });
        previewDiv.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            e.preventDefault();
            const x = e.pageX - previewDiv.offsetLeft;
            const y = e.pageY - previewDiv.offsetTop;
            const walkX = (x - startX);
            const walkY = (y - startY);
            previewDiv.scrollLeft = scrollLeftInit - walkX;
            previewDiv.scrollTop = scrollTopInit - walkY;
        });
    }

    function updateGenderColorPreference() {
        if (!treeContainer || !toggleGenderColorBtn) return;
        if (toggleGenderColorBtn.checked) {
            treeContainer.classList.remove('no-gender-colors');
        } else {
            treeContainer.classList.add('no-gender-colors');
        }
         if (rendererInstance) { // Re-apply styles to existing tree if renderer exists
            const personsInTree = treeContainer.querySelectorAll('.person');
            personsInTree.forEach(personEl => {
                const personId = personEl.getAttribute('data-id');
                if (personId && rendererInstance.data.persons[personId]) {
                    // Reset inline styles that might have been set by applyStyles
                    personEl.style.backgroundColor = '';
                    personEl.style.borderColor = '';
                    // Re-apply styles respecting the toggle
                    rendererInstance.applyStyles(personEl, rendererInstance.data.persons[personId]);
                }
            });
        }
    }

    if (toggleGenderColorBtn) {
        toggleGenderColorBtn.addEventListener('change', () => {
            updateGenderColorPreference();
        });
    }

    if (toggleEditorBtn && editorTextarea && editorContainer && previewWrapper) {
        toggleEditorBtn.addEventListener('click', () => {
            editorTextarea.classList.toggle('hidden');
            editorContainer.classList.toggle('editor-hidden');

            if (editorTextarea.classList.contains('hidden')) {
                toggleEditorBtn.textContent = '顯示編輯器';
            } else {
                toggleEditorBtn.textContent = '隱藏編輯器';
            }
            // Recalculate sibling lines after layout change (with a small delay)
            setTimeout(adjustSiblingConnectorLines, 550); // Match transition duration
        });
    } else {
        if (!toggleEditorBtn) console.warn("#toggle-editor-btn not found.");
        if (!editorTextarea) console.warn("#ftdl-editor (editorTextarea) not found.");
        if (!editorContainer) console.warn(".editor-container not found.");
        if (!previewWrapper) console.warn("#preview-wrapper not found.");
    }

    function adjustSiblingConnectorLines() {
        if (!treeContainer) return;
        const connectorLineElements = treeContainer.querySelectorAll('.siblings-connector-line');
        connectorLineElements.forEach(lineEl => {
            const parentContainer = lineEl.parentElement; 
            if (!parentContainer) return; 
            const siblingsRow = parentContainer.nextElementSibling; 
            
            if (!siblingsRow || !siblingsRow.classList.contains('siblings-row') || siblingsRow.children.length === 0) {
                lineEl.style.width = '0px';
                lineEl.style.left = '0px';
                return;
            }

            const descendantPersons = Array.from(siblingsRow.querySelectorAll('.person.descendant-link'));
            
            if (descendantPersons.length === 0) {
                 lineEl.style.width = '0px'; 
                 lineEl.style.left = '0px';
                 return;
            }
            if (descendantPersons.length === 1) {
                lineEl.style.width = '2px'; 
                const singleDescendantRect = descendantPersons[0].getBoundingClientRect();
                const lineContainerRect = parentContainer.getBoundingClientRect();
                if (singleDescendantRect.width === 0 && singleDescendantRect.height === 0 && lineContainerRect.width === 0 && lineContainerRect.height === 0) {
                     return;
                }
                const singleCenter = (singleDescendantRect.left - lineContainerRect.left) + (singleDescendantRect.width / 2);
                lineEl.style.left = `${singleCenter - 1}px`;
                return;
            }

            const firstDescendantRect = descendantPersons[0].getBoundingClientRect();
            const lastDescendantRect = descendantPersons[descendantPersons.length - 1].getBoundingClientRect();
            const containerRect = parentContainer.getBoundingClientRect(); 

            if ((firstDescendantRect.width === 0 && firstDescendantRect.height === 0) || 
                (lastDescendantRect.width === 0 && lastDescendantRect.height === 0) ||
                (containerRect.width === 0 && containerRect.height === 0) ) {
                return;
            }

            const firstCenter = (firstDescendantRect.left - containerRect.left) + (firstDescendantRect.width / 2);
            const lastCenter = (lastDescendantRect.left - containerRect.left) + (lastDescendantRect.width / 2);
            
            const minLeft = Math.min(firstCenter, lastCenter);
            const maxRight = Math.max(firstCenter, lastCenter);
            
            lineEl.style.left = `${minLeft}px`;
            lineEl.style.width = `${Math.max(2, maxRight - minLeft)}px`;
        });
    }

    let rendererInstance = null;

    function doRender() {
        const ftdlCode = editorTextarea ? editorTextarea.value : ""; 
        const actualTreeContentHolder = document.getElementById('family-tree-container'); 

        if (actualTreeContentHolder) {
            actualTreeContentHolder.innerHTML = '';
        } else {
            console.error("#family-tree-container (actualTreeContentHolder) not found for clearing.");
            return;
        }

        if (errorMessageDiv) {
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';
        }

        try {
            const parser = new FTDLParser();
            const parsedData = parser.parse(ftdlCode);

            if (!parsedData || !parsedData.persons || Object.keys(parsedData.persons).length === 0) {
                if (actualTreeContentHolder) actualTreeContentHolder.innerHTML = '<p style="text-align:center; color: #777;">無數據可渲染或無人物定義。</p>';
                return;
            }
            
            rendererInstance = new FamilyTreeRenderer(parsedData, previewDiv, treeContainer);
            const treeElement = rendererInstance.render();

            if (actualTreeContentHolder && treeElement) { 
                actualTreeContentHolder.appendChild(treeElement);
            }
            
            if (toggleGenderColorBtn) updateGenderColorPreference(); 

            requestAnimationFrame(() => {
                requestAnimationFrame(adjustSiblingConnectorLines);
            });

        } catch (error) {
            console.error("FTDL 渲染錯誤:", error);
            if (errorMessageDiv) {
                errorMessageDiv.textContent = `渲染錯誤: ${error.message}\n${error.stack ? error.stack : ''}`;
                errorMessageDiv.style.display = 'block';
            }
        }
    }

    if (renderBtn) {
        renderBtn.addEventListener('click', doRender);
    }

    if (editorTextarea && editorTextarea.value.trim() !== "") {
        doRender();
    } else if (!editorTextarea) {
        console.warn("#ftdl-editor (editorTextarea) not found for initial render check.");
    }
});

function parseComplexCsv(csvString) {
    const rows = [];
    let currentRow = [];
    let currentField = '';
    let inQuotedField = false;

    // Normalize line endings to \n for simpler parsing
    csvString = csvString.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    for (let i = 0; i < csvString.length; i++) {
        const char = csvString[i];

        if (inQuotedField) {
            if (char === '"') {
                // Check for an escaped quote ("")
                if (i + 1 < csvString.length && csvString[i + 1] === '"') {
                    currentField += '"';
                    i++; // Consume the second quote of the pair
                } else {
                    // This is the closing quote of a quoted field
                    inQuotedField = false;
                }
            } else {
                // Character inside a quoted field (could be a newline)
                currentField += char;
            }
        } else { // Not in a quoted field
            if (char === '"' && currentField === '') { // Start of a new quoted field
                 // This condition `currentField === ''` ensures it's a field starting with a quote,
                 // not a quote appearing mid-unquoted-field (which is malformed CSV but we try to be strict for gviz)
                inQuotedField = true;
            } else if (char === ',') {
                // End of a field
                currentRow.push(currentField);
                currentField = '';
            } else if (char === '\n') {
                // End of a row
                currentRow.push(currentField); // Add the last field of the row
                rows.push(currentRow);
                currentRow = [];
                currentField = '';
            } else {
                // Character in an unquoted field
                currentField += char;
            }
        }
    }

    // Add the last field of the last row if the CSV doesn't end with a newline
    currentRow.push(currentField);
    rows.push(currentRow);
    
    // Filter out any completely empty rows that might result from trailing newlines in csvString
    return rows.filter(row => row.length > 1 || (row.length === 1 && row[0] !== ''));
}
    </script>
</body>
</html>